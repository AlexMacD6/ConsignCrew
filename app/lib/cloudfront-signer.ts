import { getSignedUrl } from '@aws-sdk/cloudfront-signer';

/**
 * CloudFront URL Signer for Secure Photo Access
 * 
 * This utility generates time-limited signed URLs for photos stored in S3
 * and served through CloudFront. This prevents unauthorized access to photos.
 * 
 * Security Features:
 * - Time-limited URLs (default: 60 minutes)
 * - Cannot be guessed or generated by users
 * - Automatically expire after the specified time
 * - Forces all access through CloudFront (not direct S3)
 */

interface SignedUrlOptions {
  expiresInMinutes?: number;
  ipAddress?: string; // Optional: restrict to specific IP
}

/**
 * Generate a signed CloudFront URL for secure photo access
 * 
 * @param s3Key - The S3 key of the photo (e.g., "photo-gallery/user123/photo.jpg")
 * @param options - Configuration options for the signed URL
 * @returns Signed CloudFront URL that expires after the specified time
 * 
 * @example
 * const secureUrl = generateSignedPhotoUrl('photo-gallery/user123/photo.jpg', { expiresInMinutes: 30 });
 */
export function generateSignedPhotoUrl(
  s3Key: string,
  options: SignedUrlOptions = {}
): string {
  const { expiresInMinutes = 60 } = options;

  // Get CloudFront configuration from environment variables
  const cloudFrontDomain = process.env.NEXT_PUBLIC_CDN_URL?.replace(/^https?:\/\//, '');
  const keyPairId = process.env.CLOUDFRONT_KEY_PAIR_ID;
  const privateKey = process.env.CLOUDFRONT_PRIVATE_KEY;

  // Validate configuration
  if (!cloudFrontDomain) {
    console.warn('⚠️ NEXT_PUBLIC_CDN_URL not configured, using fallback domain');
    const fallbackDomain = 'dtlqyjbwka60p.cloudfront.net';
    return `https://${fallbackDomain}/${s3Key}`;
  }

  // If CloudFront signing is not fully configured, return unsigned URL
  if (!keyPairId || !privateKey) {
    console.warn('⚠️ CloudFront signing not configured (missing key pair ID or private key)');
    console.warn('   Photos will use unsigned URLs. Configure CLOUDFRONT_KEY_PAIR_ID and CLOUDFRONT_PRIVATE_KEY for security.');
    return `https://${cloudFrontDomain}/${s3Key}`;
  }

  // Construct the full CloudFront URL
  const url = `https://${cloudFrontDomain}/${s3Key}`;
  
  // Calculate expiration time
  const expirationTime = new Date(Date.now() + expiresInMinutes * 60 * 1000);

  try {
    // Format private key (replace escaped newlines)
    const formattedPrivateKey = privateKey.replace(/\\n/g, '\n');

    // Generate signed URL
    const signedUrl = getSignedUrl({
      url,
      keyPairId,
      dateLessThan: expirationTime.toISOString(),
      privateKey: formattedPrivateKey,
    });

    console.log(`✓ Generated signed URL for ${s3Key} (expires in ${expiresInMinutes} min)`);
    return signedUrl;
  } catch (error) {
    console.error('❌ Error generating signed URL:', error);
    console.error('   Falling back to unsigned URL');
    
    // Fallback to unsigned URL if signing fails
    return url;
  }
}

/**
 * Generate signed URLs for multiple photos
 * 
 * @param s3Keys - Array of S3 keys
 * @param options - Configuration options
 * @returns Array of signed URLs in the same order as input
 */
export function generateSignedPhotoUrls(
  s3Keys: string[],
  options: SignedUrlOptions = {}
): string[] {
  return s3Keys.map(key => generateSignedPhotoUrl(key, options));
}

/**
 * Check if CloudFront signing is properly configured
 * 
 * @returns true if CloudFront signing is configured and ready to use
 */
export function isCloudFrontSigningConfigured(): boolean {
  const keyPairId = process.env.CLOUDFRONT_KEY_PAIR_ID;
  const privateKey = process.env.CLOUDFRONT_PRIVATE_KEY;
  const cloudFrontDomain = process.env.NEXT_PUBLIC_CDN_URL;

  return !!(keyPairId && privateKey && cloudFrontDomain);
}

/**
 * Extract S3 key from a full CloudFront or S3 URL
 * 
 * @param url - Full URL to extract key from
 * @returns S3 key or the original URL if extraction fails
 * 
 * @example
 * extractS3Key('https://cdn.example.com/photo-gallery/user/photo.jpg')
 * // Returns: 'photo-gallery/user/photo.jpg'
 */
export function extractS3Key(url: string): string {
  try {
    const urlObj = new URL(url);
    // Remove leading slash
    return urlObj.pathname.substring(1);
  } catch {
    // If URL parsing fails, assume it's already a key
    return url;
  }
}

